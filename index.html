<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
  <style type="text/css">
  body
  {
    margin:40px auto;
    max-width:650px;
    line-height:1.6;
    font-size:18px;
    color:#444;
    padding:0 10px;
  }

  h1,h2,h3
  {
    line-height:1.2;
  }

  pre{
    background-color:ghostwhite;
    padding: 0 20px 0 20px;
  }

  code {
    line-height: 1.2;
    font-size:16px;
  }

  </style>
  </head>
  <body>


<header>
  <h2>a programming blog by a retired pro-gamer</h2>
</header>

<article>
<h2>
profiling in golang
</h2>
<p>
About a month ago I was working on my submission to the third go challenge, building a web application which produces mosaics from uploaded images. Two winners were announced, and my submissioned received a mention as being "very close", with feedback that while my mosaics were "excellent", the runtime was "pretty slow". This is uncharacteristic of my applications, as I will always at least benchmark my runtimes, and if necessary either optimize hotspots or avoid them at a higher level. I knew my runtimes were high (90 seconds), about 60s of which were spent processing, but at the time I did not know about the tools which could make it easy to profile my code at a higer resolution. If i had, only a couple minutes of effort would have cut my processing time in half or better.
</p>
<p>
After the winners were revealed, the source code of all entries were made public on github. Looking at the winning submissions, I realized that their processing was much simplier then mine. While this could have been an advantage for me, any benefits were far outweighed by the effect on the application's runtime.


</p>
<p>
From the beginning my hypothesis on mosaics was that matching the intensity of the underlying image was key, as I had an idea that people do not perceive differences in color that well compared to grayscale (which is a translation of intensity or luminosity into equal parts rgb). Somehow tiles would have to be selected to fit each part of the mosaic based on their average color, and so I wanted to find a way to downsample the tile images while preserving the intensity. As it turns out, <a href="http://www.4p8.com/eric.brasseur/gamma.html">most image scaling algorithms have an error</a>, which results from averaging colors as if the intensity encoded in the rgb format were on a linear scale. This is analogous to trying to find the hypotenuse of a triangle with the equation A + B = C.
</p>
<p>
My tests showed that the go standard library drawing package made this error. My solution was to manually downsample images by first transforming into a linear colorspace, averaging, and then transforming back to srgb. I could tell my mosaics were improved by this, particularly around areas of detail such as facial features.
</p>

<p>
Using Dave Cheney's <a href="https://github.com/pkg/profile">profile package</a>, you only need to add two lines of code to generate profiling data while running your application. Afterwards, use pprof with the --text flag (pdf/svg graphs are also available) to generate text output.
</p>

<pre><code>
p := profile.Start(profile.CPUProfile, profile.ProfilePath("."), profile.NoShutdownHook)
defer p.Stop()
</code></pre>

<pre><code>
go tool pprof --text yourprogram.exe cpu.pprof > profile.txt
</code></pre>

<pre><code>
20.17s 18.34%  math.Exp
13.17s 11.98%  math.Log
52.94s 48.14%  math.Pow
58.09s 52.82%  main.sRGBtoLinear
62.65s 56.97%  main.averageColor
21.07s 19.16%  main.convertToRGBA
2s  1.82%  main.lineartosRGB
</code></pre>

<p>
From this selection of my profile output, it is clear that two function calls make up most of my processing time. The first is convertToRGBA, which is the step which cleans tile images, converting them from whatever format they were stored in to rgba, which is the format my algorithm works in. The vast majority of the tile source images I am using are in jpeg format, which store color in YCbCr, which must all then be converted to rgba. This is essentially 21 wasted seconds, as I could have chosen to work in the YCbCr colorspace, however jpeg has a number of sub-formats which make it more difficult to work with the underlying color data.
</p>

<p>
Luckily the biggest waste of time is in math calls, almost exclusivly coming from the sRGBtoLinear function (which in turn is called from averageColor). sRGBtoLinear takes in a uint8, representing one of the red, green, or blue channels, and returns a float64. Because there is at most 256 different inputs, all of these costly calls to math functions can be avoided by instead precomputing a lookup table. In general a map can be used for a lookup, but in this case the keys are ints so this is one of the few opportunities to use an array in go.
</p>

<pre><code>
3.04s  5.77%  main.averageColor
21.39s 40.59%  main.convertToRGBA
</code></pre>

<p>
The new profile confirms the improvement, from 62.65s to 3.04s. There is still alot of time being spent converting from YCbCr to RGBA, however this part of my pipeline is limited not just by the time spent processing, but also by the download bandwidth. For each mosaic request, a list of 1500 images is consumed by 200 worker goroutines in parallel, where the image is downloaded -> converted -> downsampled. At least some of the time spent converting will overlap with time otherwise spent waiting on the network.
</p>

</article>

<article>
<h2>firebase as a restful api for android apps</h2>
<p>
If you've seen alot of movies, there may come a point where you have trouble finding the next good film to watch. Imdb is a great resource for quickly finding information on a specific movie or actor, but not as great at displaying relationships between them. You may know that Denzel Washington is your favorite actor, but not which of his 54 credits are worth your time.
</p><p>
Luckily imdb makes all this information available in text format, which can be parsed, filtered, and transformed into json. Learning from previous work, it was decided to store our movie data somewhere that would not have to be maintained. While not designed to be used as a rest api, Firebase is versatile enough for this purpose. More then just a document store, it provides some sort and search capability which allows us to query without writing our own backend code.
</p>
<pre><code>
x.firebaseio.com/tevs.json?orderBy=\"$key\"&limitToFirst={count}&startAt=\"{key}\"
</code></pre>
<p>
By keying our movies with a url encoded version of their name, this more or less allows us to search by movie title. Again learning from the complexity of previous apps, getting movie recommendations would be a simple two step process. The general flow of our app would be to allow the user to search for a movie they already know, then aggregate all the movies related through the cast and use some heuristic to rank them as suggestions.
</p>
<p>
In addition to searching by title, it is necessary to easily move both ways across relationships between actors and films by just accessing our firebase api. As such, each actor object would hold a list of movie ids, and each movie would hold a list of cast ids. Because firebase limits us to a single key per object, movie data has to be duplicated and stored a second time in order to allow a second lookup by id. In retrospect, it would have been sufficient to reference movies by string and reuse the earlier dataset. Firebase does store sparse arrays and objects differently than arrays, so there may be some performance benefit with this method.
</p>
   <p>
 One of the caveats of android development is that it is not possible to fully control the lifecycle of an app. External factors, for example if the phone is rotated into landscape view, can cause our activity's process to be destroyed and recreated. Relying on state stored in the activity can easily cause crashes due to null errors, or at best, require users to redo network calls to our api. It is both easier to reason about and more robust to decouple our long running background tasks from our activity process.
  </p>
<p>
  Thanks to Otto, an open source message bus from <a href="http://square.github.io/">square</a>, it is simple for the two parts of our application to communicate. Otto communicates with events. To begin our search, a search event is posted from our activity with a property containing the query string. In our service, an annotated subscriber method is called, which handles calling our api and parsing the results. Our service in turn posts a result event, which could be handled by zero, one, or multiple subscribers.
</p>
<p>
  In this case, there will only ever be at most one subscriber, in our activity class. In the case the activty is in a transient state, in between being shut down and recreated, there will be no active subscriber, however our results will not be lost. Otto also provides a producer annotation, which is called immediately whenever a subscriber registers to listen for an event. Whenever our new activity is created, this provider will immediately run, returning the most recent result (which we cached in our service).
</p>
<p>
  Because of the nature of our app, there are many api calls, each returning data which must then be aggregated before returning a result. Because Firebase is primarily a real time streaming service, not a restful api provider, the official android library for firebase was awkward to use for our purpose. Due to this, a basic library for making http calls to firebase in parallel was created, using a similiar api to firebase's own library.
</p>

</article>


  </body>
  </html>
