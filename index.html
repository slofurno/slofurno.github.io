<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
  <style type="text/css">
  body
  {
    margin:40px auto;
    max-width:650px;
    line-height:1.6;
    font-size:18px;
    color:#444;
    padding:0 10px;
  }

  h1,h2,h3
  {
    line-height:1.2;
  }

  pre{
    background-color:ghostwhite;
    padding: 0.75em 1.625em;
    font-size:16px;
    overflow: auto;
  }


  </style>
  </head>
  <body>


<header>
  <h2>a programming blog by a retired pro-gamer</h2>
</header>

<article>
Commits on Jun 18, 2015
<h2>
profiling in golang
</h2>
<p>
About a month ago I was working on my submission to the third go challenge, building a web application which produces mosaics from uploaded images. Two winners were announced, and my submissioned received a mention as being "very close", with feedback that while my mosaics were "excellent", the runtime was "pretty slow". This is uncharacteristic of my applications, as I am conscious of performance, but I was new to go at the time, and was focusing on learning the language. I knew my runtimes were high (90 seconds), but at the time I did not know about the tools which could make it easy to profile my code at a higer resolution.
</p>

<img src="static/gochallenge.jpg">

<p>
After the winners were revealed, the source code of all entries were made public on github. Looking at the winning submissions, I realized that their image processing was much simplier then mine. While this should have been a winning advantage for me, any benefits were far outweighed by the increase on the application's runtime. The effort I had put into a more robust and correct image matching algorithm paled in comparision to the importance of the overall user experience, where speed and responsiveness are highly rated.


</p>
<p>
When I was younger I recieved a black and white mosaic of abraham lincoln as a gift. Even though it was only composed of maybe 20 by 40 images, i remember being impressed at how clear the overall picture was, even though the content of the images was all rather uniform. The images were either landscapes or portraits, yet at a distance the details of the images blurred and their relative lightness or darkness was all that mattered.
</p>

<p>
Thus I began with the idea that the intensity of the underlying images was key for producing a good mosaic. After doing some research, I found that there was a common mistake that many naive, and even professional, image scaling algorithms made, which skewed the intensity of the resulting images. You can <a href="http://www.4p8.com/eric.brasseur/gamma.html">read more about this effect here</a>, which results from averaging colors as if the intensity encoded in the rgb format were on a linear scale, when it is really on a power scale to pack more visible detail into a limited 8 bit space. Simply taking the rgb colors and averaging them is analogous to trying to find the hypotenuse of a triangle with the equation A + B = C.
</p>
<p>
My tests showed that the go standard library drawing package made this error. My solution was to write my own code to downsample images by first transforming into a linear colorspace, averaging, and then transforming back to srgb. I could tell my mosaics were improved by this, particularly around areas of detail such as facial features, however this now meant doing an expensive math operation on every pixel of every source image in my pre processing stage.
</p>
<pre>
  func sRGBtoLinear(s uint8) float64 {

  	var z float64 = float64(s) / 255
  	var L float64

  	if z > 0.04045 {
  		L = math.Pow((z+0.055)/(1.055), 2.4)
  	} else {
  		L = z / 12.92
  	}

  	return L
  }
</pre>

<p>
Using Dave Cheney's <a href="https://github.com/pkg/profile">profile package</a>, we find that more then half of our overall runtime (including network operations to download our source images) takes place in this conversion function, specifically 48% of our runtime, or 52 seconds, is spent calling the math.Pow function.
</p>

<p>
Now that we have established that we have a function containing expensive math calls with only 256 possible inputs which is called millions of times, a possible solution becomes obvious. The new conversion function becomes a lookup and we precompute the results for all possible inputs.
</p>

<p>
A new profile confirms the improvement, from 62.65s to 3.04s spent in pre-processing.
</p>

</article>

<article>
Commits on Jun 14, 2015
<h2>firebase as a restful api for android apps</h2>
<p>
If you've seen alot of movies, there may come a point where you have trouble finding the next good film to watch. Imdb is a great resource for quickly finding information on a specific movie or actor, but not as great at displaying relationships between them. You may know that Denzel Washington is your favorite actor, but not which of his 54 credits are worth your time.
</p><p>
Luckily imdb makes all this information available in text format, which can be parsed, filtered, and transformed into json. Learning from previous work, it was decided to store our movie data somewhere that would not have to be maintained. While not designed to be used as a rest api, Firebase is versatile enough for this purpose. More then just a document store, it provides some sort and search capability which allows us to query without writing our own backend code.
</p>
<pre>
x.firebaseio.com/tevs.json?orderBy=\"$key\"&limitToFirst={count}&startAt=\"{key}\"
</pre>
<p>
By keying our movies with a url encoded version of their name, this more or less allows us to search by movie title. Again learning from the complexity of previous apps, getting movie recommendations would be a simple two step process. The general flow of our app would be to allow the user to search for a movie they already know, then aggregate all the movies related through the cast and use some heuristic to rank them as suggestions.
</p>
<p>
In addition to searching by title, it is necessary to easily move both ways across relationships between actors and films by just accessing our firebase api. As such, each actor object would hold a list of movie ids, and each movie would hold a list of cast ids. Because firebase limits us to a single key per object, movie data has to be duplicated and stored a second time in order to allow a second lookup by id. In retrospect, it would have been sufficient to reference movies by string and reuse the earlier dataset. Firebase does store sparse arrays and objects differently than arrays, so there may be some performance benefit with this method.
</p>
   <p>
 One of the caveats of android development is that it is not possible to fully control the lifecycle of an app. External factors, for example if the phone is rotated into landscape view, can cause our activity's process to be destroyed and recreated. Relying on state stored in the activity can easily cause crashes due to null errors, or at best, require users to redo network calls to our api. It is both easier to reason about and more robust to decouple our long running background tasks from our activity process.
  </p>
<p>
  Thanks to Otto, an open source message bus from <a href="http://square.github.io/">square</a>, it is simple for the two parts of our application to communicate. Otto communicates with events. To begin our search, a search event is posted from our activity with a property containing the query string. In our service, an annotated subscriber method is called, which handles calling our api and parsing the results. Our service in turn posts a result event, which could be handled by zero, one, or multiple subscribers.
</p>
<p>
  In this case, there will only ever be at most one subscriber, in our activity class. In the case the activty is in a transient state, in between being shut down and recreated, there will be no active subscriber, however our results will not be lost. Otto also provides a producer annotation, which is called immediately whenever a subscriber registers to listen for an event. Whenever our new activity is created, this provider will immediately run, returning the most recent result (which we cached in our service).
</p>
<p>
  Because of the nature of our app, there are many api calls, each returning data which must then be aggregated before returning a result. Because Firebase is primarily a real time streaming service, not a restful api provider, the official android library for firebase was awkward to use for our purpose. Due to this, a basic library for making http calls to firebase in parallel was created, using a similiar api to firebase's own library.
</p>

</article>


  </body>
  </html>
