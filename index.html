<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
  <style type="text/css">
  body
  {
    margin:40px auto;
    max-width:650px;
    line-height:1.6;
    font-size:18px;
    color:#444;
    padding:0 10px;
  }

  h1,h2,h3
  {
    line-height:1.2;
  }

  pre{
    background-color:ghostwhite;
    padding: 0.75em 1.625em;
    font-size:16px;
    overflow: auto;
  }


  </style>
  </head>
  <body>


<header>
  <h2>a programming blog by a retired pro-gamer</h2>
</header>

<article>
  Commits on September 10, 2015
  <h2>
    writing go in c#
  </h2>
<p>
It has been awhile since I've found something to write about. For a long time I was hoping to write an implementation for techempower's performance benchmark, as c# is <a href="https://www.techempower.com/benchmarks/#section=data-r10&hw=ec2&test=json">very poorly represented there.</a> For example, on a 2 core ec2 instance, the only c# framework which ran produced 169 responses per second, a tiny fraction of the 86,480 of the top performer. From experience I know that even running a web api on top of a default httplistener could produce at least 10k json responses a second on similiar hardware, and I hoped to gain even greater throughput by dropping down into lower level but higher performance apis and using socketasynceventargs to try and minimize the stress on the gc.
</p>

<p>
Long story short, the performance benefits were marginal, and I was running into serious issues on mono. While everything worked fine on windows server, when running on a linux machine under mono it seemed that socket objects were not being properly reused. The webserver would leak filedescriptors, and after serving 50,000 requests it would throw an exception. This is not the first inconsistency I have found between mono and the clr on windows. In the past I have found subtle issues between some lesser user functionality such as memory mapped files.
</p>

<p>
At some point I may write more about the awesome tempest tracker I created for this past season of path of exile, which was finished but never released to the public. Built in react with a blazing fast go backend, the site was designed to push realtime updates to a large concurrent userbase.
</p>

<p>
One of the benefits of using React is that you don't have to think much about the state of your ui. Anytime your viewmodel is updated, React will re-render its virtual dom and then calculate which real dom elements need to be updated. This seemed to work great out of the box until I started stress testing the site with hundreds or thousands of updates a second. This was to simluate high user activity, reporting tempests, up or downvoting, adding comments, all of which had to be updated in real time. Its here that React fell over with the sheer quantity of updates. While I solved this by batching updates that were pushed from the server, it felt a little ugly to essentially tell React to re-dif its virtual dom at a pre-defined fps.
</p>

<p>
More recently I was sitting around talking to some friends about ideas for some multipler game to spend time on between doing other things, and someone floated the idea for a minesweeper game. In typical hackathon style I had a playable game the following day, but since then I have spent some time thinking about how I could refactor both the client and server.
</p>

<p>
  I wanted the server, written in c#, to have its parts less coupled. I wanted the flexibility to add some features like multiple games going on at once or a global high score. So far I've been solving this by using c#'s BufferBlock. Similiar to channels in go, they allow events or objects to be passed around between different workers. I think this should lend itself to players moving between minesweeper games.
</p>

<p>
  The client I had decided to hack together in a very imperative style using divs to represent the tiles of the minesweeper game. While this code performed very well, and was very simple to update with each state change, I felt like it would be a little fragile when I tried adding some of the auxilary features that people were requesting.
</p>

<p>
My first attempt at a solution was to start using Mithril to render the scoreboard, but I still remaing skeptical the libray won't suffer from the same issue that React did when I try to render the game state with it as well. I've created html5 games in the past in the traditional mvc using the canvas or webgl to render, so I am interested to see how this scales, since it is definaly much easier creating squares in the dom then in opengl.
</p>

</article>

<article>
Commits on Jun 18, 2015
<h2>
profiling in golang
</h2>
<p>
About a month ago I was working on my submission to the third go challenge, building a web application which produces mosaics from uploaded images. Two winners were announced, and my submissioned received a mention as being "very close", with feedback that while my mosaics were "excellent", the runtime was "pretty slow". This is uncharacteristic of my applications, as I am conscious of performance, but I was new to go at the time, and was focusing on learning the language. I knew my runtimes were high (90 seconds), but I did not know how easy it could be to profile my code at a higer resolution with the right tools.
</p>

<img src="static/gochallenge.jpg">

<p>
After the winners were revealed, the source code of all entries were made public on github. Looking at the winning submissions, I realized that their image processing was much simplier then mine. While this should have been a winning advantage for me, any benefits were far outweighed by the increase on the application's runtime. The effort I had put into a more robust and correct image matching algorithm paled in comparision to the importance of the overall user experience, where speed and responsiveness are highly rated.


</p>
<p>
When I was younger I recieved a black and white mosaic of abraham lincoln as a gift. Even though it was only composed of maybe 20 by 40 images, i remember being impressed at how clear the overall picture was, even though the content of the images was all rather uniform. The images were either landscapes or portraits, yet at a distance the details of the images blurred and their relative lightness or darkness was most important.
</p>

<p>
Thus I began with the idea that the intensity of the underlying images was key for producing a good mosaic. After doing some research, I found that there was a common mistake that many naive, and even professional, image scaling algorithms made, which skewed the intensity of the resulting images. You can <a href="http://www.4p8.com/eric.brasseur/gamma.html">read more about this effect here</a>, which results from averaging colors as if the intensity encoded in the rgb format were on a linear scale, when it is really on a power scale to pack more visible detail into a limited 8 bit space. Simply taking the rgb colors and averaging them is analogous to trying to find the hypotenuse of a triangle with the equation A + B = C.
</p>
<p>
My tests showed that the go standard library drawing package made this error. My solution was to write my own code to downsample images by first transforming into a linear colorspace, averaging, and then transforming back to srgb. I could tell my mosaics were improved by this, particularly around areas of detail such as facial features, however this now meant doing an expensive math operation on every pixel of every source image in my pre processing stage.
</p>
<pre>
  func sRGBtoLinear(s uint8) float64 {

  	var z float64 = float64(s) / 255
  	var L float64

  	if z > 0.04045 {
  		L = math.Pow((z+0.055)/(1.055), 2.4)
  	} else {
  		L = z / 12.92
  	}

  	return L
  }
</pre>

<p>
Using Dave Cheney's <a href="https://github.com/pkg/profile">profile package</a>, we find that more then half of our overall runtime (including network operations to download our source images) takes place in this conversion function, specifically 48% of our runtime, or 52 seconds, is spent calling the math.Pow function.
</p>

<p>
Now that we have established that we have a function containing expensive math calls with only 256 possible inputs which is called millions of times, a possible solution becomes obvious. The new conversion function becomes a lookup and we precompute the results for all possible inputs.
</p>

<p>
A new profile confirms the improvement, from 62.65s to 3.04s spent in pre-processing.
</p>

</article>

<article>
Commits on Jun 14, 2015
<h2>firebase as a restful api for android apps</h2>
<p>
If you've seen alot of movies, there may come a point where you have trouble finding the next good film to watch. Imdb is a great resource for quickly finding information on a specific movie or actor, but not as great at displaying relationships between them. You may know that Denzel Washington is your favorite actor, but not which of his 54 credits are worth your time.
</p><p>
Luckily imdb makes all this information available in text format, which can be parsed, filtered, and transformed into json. Learning from previous work, it was decided to store our movie data somewhere that would not have to be maintained. While not designed to be used as a rest api, Firebase is versatile enough for this purpose. More then just a document store, it provides some sort and search capability which allows us to query without writing our own backend code.
</p>
<pre>
x.firebaseio.com/tevs.json?orderBy=\"$key\"&limitToFirst={count}&startAt=\"{key}\"
</pre>
<p>
By keying our movies with a url encoded version of their name, this more or less allows us to search by movie title. Again learning from the complexity of previous apps, getting movie recommendations would be a simple two step process. The general flow of our app would be to allow the user to search for a movie they already know, then aggregate all the movies related through the cast and use some heuristic to rank them as suggestions.
</p>
<p>
In addition to searching by title, it is necessary to easily move both ways across relationships between actors and films by just accessing our firebase api. As such, each actor object would hold a list of movie ids, and each movie would hold a list of cast ids. Because firebase limits us to a single key per object, movie data has to be duplicated and stored a second time in order to allow a second lookup by id. In retrospect, it would have been sufficient to reference movies by string and reuse the earlier dataset. Firebase does store sparse arrays and objects differently than arrays, so there may be some performance benefit with this method.
</p>
   <p>
 One of the caveats of android development is that it is not possible to fully control the lifecycle of an app. External factors, for example if the phone is rotated into landscape view, can cause our activity's process to be destroyed and recreated. Relying on state stored in the activity can easily cause crashes due to null errors, or at best, require users to redo network calls to our api. It is both easier to reason about and more robust to decouple our long running background tasks from our activity process.
  </p>
<p>
  Thanks to Otto, an open source message bus from <a href="http://square.github.io/">square</a>, it is simple for the two parts of our application to communicate. Otto communicates with events. To begin our search, a search event is posted from our activity with a property containing the query string. In our service, an annotated subscriber method is called, which handles calling our api and parsing the results. Our service in turn posts a result event, which could be handled by zero, one, or multiple subscribers.
</p>
<p>
  In this case, there will only ever be at most one subscriber, in our activity class. In the case the activty is in a transient state, in between being shut down and recreated, there will be no active subscriber, however our results will not be lost. Otto also provides a producer annotation, which is called immediately whenever a subscriber registers to listen for an event. Whenever our new activity is created, this provider will immediately run, returning the most recent result (which we cached in our service).
</p>
<p>
  Because of the nature of our app, there are many api calls, each returning data which must then be aggregated before returning a result. Because Firebase is primarily a real time streaming service, not a restful api provider, the official android library for firebase was awkward to use for our purpose. Due to this, a basic library for making http calls to firebase in parallel was created, using a similiar api to firebase's own library.
</p>

</article>


  </body>
  </html>
